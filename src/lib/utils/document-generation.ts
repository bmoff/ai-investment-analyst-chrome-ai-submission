import jsPDF from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import { Note } from '@/lib/workspace-data/mockNotes';
import { parseMarkdown, parseInlineMarkdown } from './markdown-parser';

/**
 * Generate a proper PDF document from a note
 */
export async function generatePDFDocument(note: Note, includeMetadata: boolean = true): Promise<void> {
  try {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    
    let yPosition = margin;
    
    // Add title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text(note.title, margin, yPosition);
    yPosition += 15;
    
    // Add subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Investment Research Report', margin, yPosition);
    yPosition += 20;
    
    // Add metadata if requested
    if (includeMetadata) {
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      
      const metadata = [
        `Source: ${note.sourceName}`,
        `Created: ${new Date(note.createdAt).toLocaleDateString()}`,
        `Updated: ${new Date(note.updatedAt).toLocaleDateString()}`,
        `Tags: ${note.tags.join(', ')}`
      ];
      
      metadata.forEach(line => {
        pdf.text(line, margin, yPosition);
        yPosition += 8;
      });
      
      yPosition += 10;
    }
    
    // Parse and render markdown content
    const markdownElements = parseMarkdown(note.content);
    
    for (const element of markdownElements) {
      // Check if we need a new page
      if (yPosition > pageHeight - margin - 20) {
        pdf.addPage();
        yPosition = margin;
      }
      
      switch (element.type) {
        case 'heading':
          const headingSize = Math.max(14 - (element.level || 1) * 2, 10);
          pdf.setFontSize(headingSize);
          pdf.setFont('helvetica', 'bold');
          pdf.text(element.content, margin, yPosition);
          yPosition += headingSize + 5;
          break;
          
        case 'list':
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'normal');
          element.items?.forEach((item) => {
            if (yPosition > pageHeight - margin - 20) {
              pdf.addPage();
              yPosition = margin;
            }
            pdf.text(`• ${item}`, margin + 10, yPosition);
            yPosition += 6;
          });
          yPosition += 5;
          break;
          
        case 'quote':
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'italic');
          pdf.text(`"${element.content}"`, margin + 10, yPosition);
          yPosition += 8;
          break;
          
        case 'code':
          pdf.setFontSize(10);
          pdf.setFont('courier', 'normal');
          const codeLines = pdf.splitTextToSize(element.content, contentWidth - 20);
          pdf.text(codeLines, margin + 10, yPosition);
          yPosition += codeLines.length * 5 + 5;
          break;
          
        case 'paragraph':
        default:
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'normal');
          
          // Parse inline formatting
          const inlineElements = parseInlineMarkdown(element.content);
          let currentX = margin;
          let currentY = yPosition;
          
          for (const inlineElement of inlineElements) {
            let fontStyle = 'normal';
            if (inlineElement.type === 'bold') {
              fontStyle = 'bold';
            } else if (inlineElement.type === 'italic') {
              fontStyle = 'italic';
            }
            
            pdf.setFont('helvetica', fontStyle);
            
            // Check if text fits on current line
            const textWidth = pdf.getTextWidth(inlineElement.content);
            if (currentX + textWidth > pageWidth - margin) {
              currentX = margin;
              currentY += 6;
              
              // Check if we need a new page
              if (currentY > pageHeight - margin - 20) {
                pdf.addPage();
                currentY = margin;
              }
            }
            
            pdf.text(inlineElement.content, currentX, currentY);
            currentX += textWidth;
          }
          
          yPosition = currentY + 8;
          break;
      }
    }
    
    // Add footer
    const footerY = pageHeight - 15;
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'italic');
    pdf.text('Generated by AI Investment Analyst', margin, footerY);
    pdf.text('Confidential - For Internal Use Only', pageWidth - margin - pdf.getTextWidth('Confidential - For Internal Use Only'), footerY);
    
    // Generate filename and save
    const timestamp = new Date().toISOString().split('T')[0];
    const safeTitle = note.title.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '-').toLowerCase();
    const filename = `${safeTitle}-${timestamp}.pdf`;
    
    pdf.save(filename);
  } catch (error) {
    console.error('PDF generation failed:', error);
    throw new Error('Failed to generate PDF. Please try again.');
  }
}

/**
 * Convert markdown elements to Word document elements
 */
function parseMarkdownToWordElements(content: string): Paragraph[] {
  const elements: Paragraph[] = [];
  const markdownElements = parseMarkdown(content);
  
  for (const element of markdownElements) {
    switch (element.type) {
      case 'heading':
        const headingLevel = element.level === 1 ? HeadingLevel.HEADING_1 :
                           element.level === 2 ? HeadingLevel.HEADING_2 :
                           element.level === 3 ? HeadingLevel.HEADING_3 :
                           element.level === 4 ? HeadingLevel.HEADING_4 :
                           element.level === 5 ? HeadingLevel.HEADING_5 :
                           HeadingLevel.HEADING_6;
        
        elements.push(new Paragraph({
          text: element.content,
          heading: headingLevel,
          spacing: { after: 200 },
        }));
        break;
        
      case 'list':
        element.items?.forEach(item => {
          elements.push(new Paragraph({
            text: item,
            bullet: { level: 0 },
            spacing: { after: 100 },
          }));
        });
        elements.push(new Paragraph({ text: '', spacing: { after: 200 } })); // Spacer
        break;
        
      case 'quote':
        elements.push(new Paragraph({
          children: [
            new TextRun({
              text: element.content,
              italics: true,
              color: '666666',
            }),
          ],
          spacing: { before: 200, after: 200 },
          indent: { left: 400 },
        }));
        break;
        
      case 'code':
        elements.push(new Paragraph({
          children: [
            new TextRun({
              text: element.content,
              font: 'Courier New',
              size: 20,
              color: '333333',
            }),
          ],
          spacing: { before: 200, after: 200 },
          indent: { left: 200 },
        }));
        break;
        
      case 'paragraph':
      default:
        // Parse inline formatting
        const inlineElements = parseInlineMarkdown(element.content);
        const textRuns: TextRun[] = [];
        
        for (const inlineElement of inlineElements) {
          const textRun = new TextRun({
            text: inlineElement.content,
            size: 22,
            bold: inlineElement.type === 'bold',
            italics: inlineElement.type === 'italic',
          });
          
          textRuns.push(textRun);
        }
        
        elements.push(new Paragraph({
          children: textRuns,
          spacing: { after: 200 },
        }));
        break;
    }
  }
  
  return elements;
}

/**
 * Generate a proper Word document from a note
 */
export async function generateWordDocument(note: Note, includeMetadata: boolean = true): Promise<void> {
  try {
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            children: [
              new TextRun({
                text: note.title,
                bold: true,
                size: 32,
                color: '2F5496',
              }),
            ],
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.LEFT,
            spacing: {
              after: 200,
            },
          }),
          
          // Subtitle
          new Paragraph({
            children: [
              new TextRun({
                text: 'Investment Research Report',
                size: 24,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.LEFT,
            spacing: {
              after: 400,
            },
          }),
          
          // Metadata section
          ...(includeMetadata ? [
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Report Details',
                  bold: true,
                  size: 20,
                }),
              ],
              heading: HeadingLevel.HEADING_1,
              spacing: {
                before: 200,
                after: 200,
              },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: `Source: ${note.sourceName}`,
                  size: 20,
                }),
              ],
              spacing: { after: 100 },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: `Created: ${new Date(note.createdAt).toLocaleString()}`,
                  size: 20,
                }),
              ],
              spacing: { after: 100 },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: `Updated: ${new Date(note.updatedAt).toLocaleString()}`,
                  size: 20,
                }),
              ],
              spacing: { after: 100 },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: `Tags: ${note.tags.join(', ')}`,
                  size: 20,
                }),
              ],
              spacing: { after: 400 },
            }),
          ] : []),
          
          // Content section
          new Paragraph({
            children: [
              new TextRun({
                text: 'Analysis Content',
                bold: true,
                size: 20,
              }),
            ],
            heading: HeadingLevel.HEADING_1,
            spacing: {
              before: 200,
              after: 200,
            },
          }),
          
          // Parse and add markdown content
          ...parseMarkdownToWordElements(note.content),
          
          // Footer
          new Paragraph({
            children: [
              new TextRun({
                text: 'Generated by AI Investment Analyst',
                size: 16,
                italics: true,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.LEFT,
            spacing: {
              before: 400,
            },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: 'Confidential - For Internal Use Only',
                size: 16,
                italics: true,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.RIGHT,
          }),
        ],
      }],
    });
    
    // Generate and save the document
    const buffer = await Packer.toBuffer(doc);
    const timestamp = new Date().toISOString().split('T')[0];
    const safeTitle = note.title.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '-').toLowerCase();
    const filename = `${safeTitle}-${timestamp}.docx`;
    
    const blob = new Blob([new Uint8Array(buffer)], { 
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
    });
    
    saveAs(blob, filename);
  } catch (error) {
    console.error('Word document generation failed:', error);
    throw new Error('Failed to generate Word document. Please try again.');
  }
}

/**
 * Generate multiple PDF documents from notes
 */
export async function generateMultiplePDFDocuments(notes: Note[], includeMetadata: boolean = true): Promise<void> {
  try {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    
    let yPosition = margin;
    let isFirstNote = true;
    
    notes.forEach((note, index) => {
      if (!isFirstNote) {
        pdf.addPage();
        yPosition = margin;
      }
      
      // Add note title
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(`${index + 1}. ${note.title}`, margin, yPosition);
      yPosition += 12;
      
      // Add note metadata
      if (includeMetadata) {
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        
        const metadata = [
          `Source: ${note.sourceName}`,
          `Created: ${new Date(note.createdAt).toLocaleDateString()}`,
          `Updated: ${new Date(note.updatedAt).toLocaleDateString()}`,
          `Tags: ${note.tags.join(', ')}`
        ];
        
        metadata.forEach(line => {
          pdf.text(line, margin, yPosition);
          yPosition += 6;
        });
        
        yPosition += 10;
      }
      
      // Parse and render markdown content for this note
      const markdownElements = parseMarkdown(note.content);
      
      for (const element of markdownElements) {
        // Check if we need a new page
        if (yPosition > pageHeight - margin - 20) {
          pdf.addPage();
          yPosition = margin;
        }
        
        switch (element.type) {
          case 'heading':
            const headingSize = Math.max(12 - (element.level || 1) * 2, 9);
            pdf.setFontSize(headingSize);
            pdf.setFont('helvetica', 'bold');
            pdf.text(element.content, margin, yPosition);
            yPosition += headingSize + 3;
            break;
            
          case 'list':
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            element.items?.forEach((item) => {
              if (yPosition > pageHeight - margin - 20) {
                pdf.addPage();
                yPosition = margin;
              }
              pdf.text(`• ${item}`, margin + 10, yPosition);
              yPosition += 5;
            });
            yPosition += 3;
            break;
            
          case 'quote':
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'italic');
            pdf.text(`"${element.content}"`, margin + 10, yPosition);
            yPosition += 6;
            break;
            
          case 'code':
            pdf.setFontSize(9);
            pdf.setFont('courier', 'normal');
            const codeLines = pdf.splitTextToSize(element.content, contentWidth - 20);
            pdf.text(codeLines, margin + 10, yPosition);
            yPosition += codeLines.length * 4 + 3;
            break;
            
          case 'paragraph':
          default:
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            
            // Parse inline formatting
            const inlineElements = parseInlineMarkdown(element.content);
            let currentX = margin;
            let currentY = yPosition;
            
            for (const inlineElement of inlineElements) {
              let fontStyle = 'normal';
              if (inlineElement.type === 'bold') {
                fontStyle = 'bold';
              } else if (inlineElement.type === 'italic') {
                fontStyle = 'italic';
              }
              
              pdf.setFont('helvetica', fontStyle);
              
              // Check if text fits on current line
              const textWidth = pdf.getTextWidth(inlineElement.content);
              if (currentX + textWidth > pageWidth - margin) {
                currentX = margin;
                currentY += 5;
                
                // Check if we need a new page
                if (currentY > pageHeight - margin - 20) {
                  pdf.addPage();
                  currentY = margin;
                }
              }
              
              pdf.text(inlineElement.content, currentX, currentY);
              currentX += textWidth;
            }
            
            yPosition = currentY + 6;
            break;
        }
      }
      
      yPosition += 15;
      isFirstNote = false;
    });
    
    // Add footer
    const footerY = pageHeight - 15;
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'italic');
    pdf.text('Generated by AI Investment Analyst', margin, footerY);
    pdf.text('Confidential - For Internal Use Only', pageWidth - margin - pdf.getTextWidth('Confidential - For Internal Use Only'), footerY);
    
    // Generate filename and save
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `investment-research-${timestamp}.pdf`;
    
    pdf.save(filename);
  } catch (error) {
    console.error('Multiple PDF generation failed:', error);
    throw new Error('Failed to generate PDF. Please try again.');
  }
}

/**
 * Generate multiple Word documents from notes
 */
export async function generateMultipleWordDocuments(notes: Note[], includeMetadata: boolean = true): Promise<void> {
  try {
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            children: [
              new TextRun({
                text: 'Investment Research Report',
                bold: true,
                size: 32,
                color: '2F5496',
              }),
            ],
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.LEFT,
            spacing: {
              after: 200,
            },
          }),
          
          // Subtitle
          new Paragraph({
            children: [
              new TextRun({
                text: `Comprehensive Analysis - ${new Date().toLocaleDateString()}`,
                size: 24,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.LEFT,
            spacing: {
              after: 400,
            },
          }),
          
          // Notes content
          ...notes.flatMap((note, index) => [
            new Paragraph({
              children: [
                new TextRun({
                  text: `${index + 1}. ${note.title}`,
                  bold: true,
                  size: 20,
                }),
              ],
              heading: HeadingLevel.HEADING_1,
              spacing: {
                before: 300,
                after: 200,
              },
            }),
            
            ...(includeMetadata ? [
              new Paragraph({
                children: [
                  new TextRun({
                    text: `Source: ${note.sourceName}`,
                    size: 18,
                    color: '666666',
                  }),
                ],
                spacing: { after: 100 },
              }),
              new Paragraph({
                children: [
                  new TextRun({
                    text: `Created: ${new Date(note.createdAt).toLocaleString()}`,
                    size: 18,
                    color: '666666',
                  }),
                ],
                spacing: { after: 100 },
              }),
              new Paragraph({
                children: [
                  new TextRun({
                    text: `Tags: ${note.tags.join(', ')}`,
                    size: 18,
                    color: '666666',
                  }),
                ],
                spacing: { after: 200 },
              }),
            ] : []),
            
            // Parse and add markdown content for this note
            ...parseMarkdownToWordElements(note.content),
          ]),
          
          // Footer
          new Paragraph({
            children: [
              new TextRun({
                text: 'Generated by AI Investment Analyst',
                size: 16,
                italics: true,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.LEFT,
            spacing: {
              before: 400,
            },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: 'Confidential - For Internal Use Only',
                size: 16,
                italics: true,
                color: '666666',
              }),
            ],
            alignment: AlignmentType.RIGHT,
          }),
        ],
      }],
    });
    
    // Generate and save the document
    const buffer = await Packer.toBuffer(doc);
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `investment-research-${timestamp}.docx`;
    
    const blob = new Blob([new Uint8Array(buffer)], { 
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
    });
    
    saveAs(blob, filename);
  } catch (error) {
    console.error('Multiple Word document generation failed:', error);
    throw new Error('Failed to generate Word document. Please try again.');
  }
}
